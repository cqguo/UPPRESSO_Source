%After we conceptualize the privacy problem into an identifier-transformation problem, the design of UPPRESSO is mainly about designing three identifier-transformation functions to generate pseudo-identities for the user and RP as well as linking the user's pseudo-identity to her account at an RP. In this section, we first present our design of these three functions to support {\em transformed RP designation} and {\em trapdoor user identification} properties, and then describe the details of the UPPRESSO system and its login flow.
%Finally, we discuss the compatibility of UPPRESSO with OIDC.


\subsection{Identity-Transformation Functions}
\label{subsec:overview}

We design three identity-transformation functions,
     $\mathcal{F}_{PID_{RP}}$, $\mathcal{F}_{PID_{U}}$ and $\mathcal{F}_{Acct}$,
    over an elliptic curve $\mathbb{E}$,
     where $G$ is a base point (or generator) of this elliptic curve and the order of $G$ is a big prime number denoted as $n$.
Table \ref{tbl:notations-protocol} lists the notations,
    and the subscript $j$ and/or the superscript $i$ may be omitted in the case of no ambiguity.

%the NIST elliptic curve $P$-256,
%the discrete logarithm problem with public parameters $p$, $q$, %and $g$, %% L不作为参数，我们说：e, n是RSA算法参数，不说2048是参数。
%$q$ is a large prime defining the finite field $\mathbb{F}_q$,
% $L$ is the length of $q$ in bits,  ($2^{L-1} < q < 2^L$)
%, and $g$ is a generator of order $q$ in $GF(p)$.
%the prime number $q$  is the order of a multiplicative subgroup of $GF(p)$, which is generated with the generator $g$ by $\{g\ mod\ p, g^2\ mod\ p, ..., g^{q-1}\ mod\ p, 1=g^q\ mod\ p\}$.

\begin{table}[tb]
\footnotesize
    \caption{The notations in the UPPRESSO protocols.}
    \centering
%    \begin{tabular}{|c|c|c|}
    \begin{tabular}{|p{1.0cm}|p{6.60cm}|} \hline
    {\textbf{Notation}} & {\textbf{Description}} \\ \hline
    {$\mathbb{E}$} & {An elliptic curve over a finite field $\mathbb{F}_q$, where the ECDLP is computationally impossible.} \\ \hline
    {$G$, $n$}&{$G$ is a base point (or generator) of $\mathbb{E}$, and the order of $G$ is a prime number $n$.} \\ \hline
%    {$q$} & {A large prime, the size of the underlying field.} \\ \hline
%    {$n$} & {the order of the base point $G$.} \\ \hline
    {$ID_U$} & {$ID_U = u$, $1 < u < n$; the user's unique identity at the IdP.} \\ \hline
   {$ID_{RP_j}$} & {$ID_{RP} = [r]G$, $1 < r < n$; the $j$-th RP's unique identity at the IdP.} \\ \hline
    {$t$} & {The user-generated random number in a login instance, $1 < t < n$.} \\ \hline
    {$PID_{RP_j}^i$} & {$PID_{RP} = [t]{ID_{RP}} = [tr]G$; the $j$-th RP's pseudo-identity, in the user's $i$-th login instance to this RP.} \\ \hline
    {$PID_{U,j}^i$} & {$PID_U = [{ID_U}]{PID_{RP}} = [utr]G$; the user's pseudo-identity, in the user's $i$-th login instance to the $j$-th RP.} \\ \hline
     {$Acct_j$} & {$Acct = [t^{-1}]PID_{U} = [ID_U]ID_{RP} = [ur]G$; the user's account at the $j$-th RP.} \\ \hline
    {$SK$, $PK$} & {The IdP's key pair, a private key and a public key, to sign and verify identity tokens and RP certificates.} \\ \hline
%    {$T$} & {The trapdoor to derive $Account$: $T=N_U^{-1} \bmod n$.} \\ \hline
    {$Enpt_{RP_j}$} & {The $j$-th RP's endpoint, to receive the identity tokens.} \\ \hline
    {$Cert_{RP_j}$} & {The RP certificate signed by the IdP, binding $ID_{RP_j}$ and $Enpt_{RP_j}$.} \\ \hline
    {$PEnpt_{U,j}^i$} & {A user-generated random ``pseudo-endpoint'', in the user's $i$-th login instance to the $j$-th RP.} \\ \hline
    \end{tabular}
    \label{tbl:notations-protocol}
\end{table}


$ID_U$ is a unique integer satisfying $1<ID_U<n$,
    and $ID_{RP}$ is a unique point on $\mathbb{E}$.
When a user is registering,
            a unique random number $u$ $(1 < u < n)$ is generated and $ID_U = u$ is assigned to this user;
    when an RP is initially registering,
            a unique random number $r$ $(1 < r < n)$ is generated by the IdP and $ID_{RP} = [r]G$ is assigned to this RP.
Here, $[r]G$ is the addition of $G$ on the curve $r$ times.
% For each RP, the IdP selects a random number $r$, where $1 < r < q$, and computes a unique $ID_{RP}$ as:
%\begin{equation}
  %  ID_{RP} = g^{r} \bmod p
   %\label{equ:IDRP}
%\end{equation}
%\noindent where $r$ is kept secret from the RP.

\vspace{1mm}
\noindent {\bf $\boldsymbol{ID_{\boldsymbol{RP}}}$-$\boldsymbol{PID_{\boldsymbol{RP}}}$ Transformation.} In each login instance,
    the user selects a random number $t$ ($1 < t <n$) as the trapdoor
         and calculates $PID_{RP}$ as below.
%First, the RP chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), and the user chooses another random number $N_{U}$ ($1 < N_{U}<q $).
%Then, they exchange $N_{RP}$ and $N_{U}$ to calculate $PID_{RP}$ following Equation \ref{equ:PIDRP}.
\begin{equation}
PID_{RP} = \mathcal{F}_{PID_{RP}}(ID_{RP}) = [t]{ID_{RP}} = [tr]G
\label{equ:PIDRP}
\end{equation}
%is a one-way function so that it

%wo nonces $N_{U}$ and $N_{RP}$ ensure that: (\emph{a}) $PID_{RP}$ is valid only for this login and for the identity token generated in this login, and (\emph{b}) $PID_{RP}$ is dynamically generated for this login and is different from other $PID_{RP}$s generated in other login session between the same user and RP. Therefore, the IdP cannot associate multiple $PID_{RP}$s of a same RP. Finally, the cooperative generation process between the user and the RP prevents a single malicious entity from manipulating the value of $PID_{RP}$.
%For example, the malicious user fails to make a correct RP accept a $PID_{RP}$ used in another login, while the collusive RPs fail to use a same or correlated $PID_{RP}$s for different logins.


\vspace{1mm}
\noindent {\bf $\boldsymbol{ID_U}$-$\boldsymbol{PID_U}$ Transformation.}
%Now, the identity token-request to the IdP contains a user identity $ID_U$ and a pseudo-identity of the RP $PID_{RP}$. Therefore,
On receiving an identity-token request with $ID_U$ and $PID_{RP}$,
    the IdP calculates $PID_{U}$.
\begin{equation}
 PID_{U} = \mathcal{F}_{PID_U}(ID_U, PID_{RP}) = [{ID_U}]{PID_{RP}} = [utr]G
 \label{equ:PIDU}
\end{equation}

%From Equations% \ref{equ:IDRP},
% \ref{equ:PIDRP} and \ref{equ:PIDU}, we see that $PID_U = ({N_UID_U} \bmod n) \cdot {ID_{RP}}$. So, $PID_U$ is a one-time pseudo-identity. It is only valid in one login session and one identity token.
%As expected, the RP cannot derive $ID_U$ from $PID_U$ due to the discrete logarithm problem, but it can associate a user's one-time pseudo-identity ($PID_U$) registered at the IdP with her long-term identifier registered at the RP (i.e., $Account$).

%Moreover, although the IdP does not know how the RP identifies the user (i.e. the user's $Account$ at the RP), involving $PID_{RP}$ in the generation of $PID_U$ indirectly links a user's one-time pseudo-identity at the IdP ($PID_U$) to her long-term identifier at the RP ($Account$) through a trapdoor.

%Moreover, $ID_{RP}$ is generated following Equation \ref{equ:IDRP} to introduce a random $r$ that is unknown to the RP, so that for a given $ID_U$, $PID_U$ is determined by $r$, $N_{U}$ and $N_{RP}$ together. Otherwise, if two collusive RPs know $r_1$ and $r_2$ respectively, they can check if ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds, which means a same user logs into them in two SSO sessions (i.e., $ID_{U_1}==ID_{U_2}$).

%Moreover, since $r$ is unknown to the RP, collusive RPs cannot link a user's $PID_U$s at different RPs. If $r$ is known to the RP, two collusive RPs might attempt to associate a user's $PID_U$s by checking whether the equality ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds or not, because ${PID_{U_1}} = g^{r_1N_{U_1}N_{RP_1}ID_{U_1}} \bmod p$ and ${PID_{U_2}} = g^{r_2N_{U_2}N_{RP_2}ID_{U_2}} \bmod p$.

\vspace{1mm}
\noindent {\bf $\boldsymbol{PID_U}$-$\boldsymbol{Acct}$ Transformation.}
In the negotiation of $PID_{RP}$,
    the user sends the trapdoor $t$ to the target RP.
So the RP also calculates $PID_{RP}$ to verify the designated RP pseudo-identity in identity tokens.
After verifying an identity token binding $PID_U$ and $PID_{RP}$,
    the RP calculates $Acct$ as below.
%As $n$ is a prime number and $1< N_U < n$, $n$ is coprime to $N_U$. So, there always exists a $T$ that satisfies $T N_U = 1 \bmod n$.
%\begin{equation}
%    k = t^{-1} \bmod n
%\end{equation}
\begin{equation}
   Acct = \mathcal{F}_{Acct}(PID_{U}, PID_{RP}) = [t^{-1} \bmod n]PID_{U}
   \label{equ:Account}
\end{equation}

From Equations \ref{equ:PIDRP}, \ref{equ:PIDU} and \ref{equ:Account}, it is derived that
%\begin{multline}\label{equ:AccountNotChanged}
%   A =  {PID_{U}}^{T}
%   = {({PID_{RP}}^{ID_U})}^{{N_U^{-1} \bmod q}} \\
%   = {ID_{RP}} ^ {ID_U N_U N_U^{-1} \bmod q}
%   = {ID_{RP}}^{ID_U} \bmod p
%\end{multline}
\begin{equation*}
   Acct =  [t^{-1}utr \bmod n]G = [ur]G = [ID_U]ID_{RP}
   \label{equ:AccountNotChanged}
\end{equation*}

The RP obtains the identical permanent account from different identity tokens in multiple login instances,
    with the help of $t$ from the user.
Given a user, the accounts at different RPs are inherently unique.
Moreover,
    (\emph{a}) due to the elliptic curve discrete logarithm problem (ECDLP),
it is computationally infeasible for the RP to derive $ID_U$ from either $PID_U$ or $Acct$;
    and (\emph{b}) because $t$ is a random number kept secret to the IdP,
        it is impossible for the IdP to derive $ID_{RP}$ from $PID_{RP}$.


\begin{comment}
\textbf{\em (i) Transformed RP designation:} using $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, the user and RP cooperatively generate a dynamic $PID_{RP}$ for each login. The identify-token request contains $PID_{RP}$ instead of $ID_{RP}$, so, the RP can verify $PID_{RP}$ is associated with $ID_{RP}$ using the trapdoor but the IdP cannot tell to which RP the user attempts to login. Also, since $PID_{RP}$s of a same RP are different in different login sessions, the IdP cannot even tell if a same RP is visited.
%Using $PID_{RP}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, the IdP generates a corresponding $PID_U$ and encloses it in the identity token to allow the user to login that RP.
%The IdP will bind $PID_{U}$ with $PID_{RP}$ in the identity token, which designates this identity token to $PID_{RP}$.
%Therefore, the $PID_{RP}$ is designated to $ID_{RP}$.
%Finally, the transformed RP designation is provided through two steps.
%The function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ prevents the curious IdP from linking $PID_{RP}$s of different logins at an RP, and
Therefore, it prevents IdP-based login tracing.
%\vspace{1mm}
%\noindent\textbf{Trapdoor User Identification.}
\textbf{\em (ii) Trapdoor user identification:} For each user, different $PID_U$s are generated by the IdP in different login sessions, no matter she requests to login a same RP multiple times or to different RPs. However, using $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, UPRESSO guarantees that an RP can always derive the unique $Account$ for each user using the dynamically generated $PID_U$ and the corresponding trapdoor in each login session. Meanwhile, collusive RPs cannot link a user's $PID_U$s and $Account$s at different RPs, and therefore prevents RP-based identity linkage.
\end{comment}



\subsection{The Design Specific for Web Applications}
We further propose the designs specific for web applications,
and these designs enable UPPRESSO to provide SSO services for users with standard browsers.
More efficient but less portable implementations with browser extensions %and/or plug-ins
 are discussed in Section \ref{sec:discussion}.
%If a user visits the IdP and RPs through a client software,
%        the specific designs become unnecessary and the performance will be improved.

First of all, in the SSO login flow,
    the user has to deal with RP endpoints (i.e., the URLs to receive identity tokens) by himself.
In existing SSO protocols,
    an RP initially registers its endpoint at the IdP,
        and then in each login instance, the IdP will set the endpoint in the identity-token response.
This instructs the user browser to forward it correctly;
    otherwise, confidentiality of identity tokens might be broken.

In UPPRESSO the IdP is not aware of the visited RP and cannot set the RP endpoints,
        so \emph{RP certificates} are designed to instruct the user agents (or browsers) about RP endpoints.
An RP certificate is a document signed by the IdP in the RP initial registration,
     binding the RP's identity and its endpoint.
This attribute certificate is sent by the RP in the login flow,
    so a user forwards identity tokens to this verified endpoint.

Secondly,
    browser scripts are needed to implement the user functions,
        including the generation of $t$ and $PID_{RP}$
            and the dealing with RP certificates and endpoints,
            for they are not standard functions of a browser.
Two scripts, one downloaded from the IdP and the other from the target RP,
    work together (with the standard  browser functions) as the user agent in UPPRESSO.
The RP script maintains the communications with the RP,
    and it does not communicates directly with the IdP because an HTTP request launched by the RP script
            will automatically carry an HTTP \verb+Referer+ header, which discloses the RP's domain.
The IdP script downloaded from the IdP,
    is responsible for the communications with the IdP,
    and two scripts communicates with each other through the \verb+postMessage+ HTML5 API.


The IdP's public key is downloaded in the IdP script to verify RP certificates. %, which are sent from the RP.
So the user agent does not configure anything locally,
    as it does in widely-adopted SSO systems.

\subsection{The UPPRESSO Protocols}
\label{implementations}


\begin{figure*}[!t]
  \centering
  \includegraphics[height=0.81\textheight]{fig/process-js.pdf}
  \caption{The SSO login flow of UPPRESSO.}
  \label{fig:process}
\end{figure*}

\noindent \textbf{System Initialization.}
%In particular, the IdP %chooses $L$,
%generates a large prime $p$, and a prime factor $q$ of $p-1$
% and a generator $g$ of order $q$
%as the parameters of the discrete logarithm problem. % \cite{gallagher2013digital}.
The IdP generates a key pair ($SK$, $PK$) to sign/verify identity tokens and RP certificates.
%The lengths of %$p$, $q$ and
%($SK$, $PK$) should satisfy the required security strength.
Then, the IdP keeps $SK$ secret, while $PK$ is publicly known.
%The values of $p$, $q$, $g$ remain the same during the full lifecycle of an SSO system.
%While, the asymmetric key pair ($SK$, $PK$) will be updated when necessary. For example, when $SK$ is leaked, IdP must update ($SK$,$PK$).


\vspace{1mm}
\noindent\textbf{RP Initial Registration.}
%Each RP launches an initial registration operation to finish configurations.
Each RP initially registers itself at the IdP to obtain $ID_{RP}$
 and the corresponding RP certificate $Cert_{RP}$ as follows:
\begin{enumerate}
%\vspace{-\topsep}
\item
The RP sends a registration request to the IdP, including the endpoint to receive identity tokens,
    and other optional information.
%\vspace{-\topsep}
\item
The IdP generates a unique random number $r$, calculates $ID_{RP} = [r]G$,
    and assigns $ID_{RP}$ to this RP.
The IdP then signs $Cert_{RP} = [ID_{RP}, Enpt_{RP}, *]_{SK}$,
     where $[\cdot]_{SK}$ means a message signed using $SK$ and $*$ denotes supplementary information such as the RP's common name and Email,
     and returns $Cert_{RP}$ to the RP.
%\vspace{-\topsep}
\item
The RP verifies $Cert_{RP}$ using $PK$,
    and accepts $ID_{RP}$ and $Cert_{RP}$ if they are valid.
%\vspace{-\topsep}
\end{enumerate}

%Note that $ID_{RP}$ is generated by the IdP but not chosen by the RP;
%otherwise, a malicious RP might choose $ID_{RP}$ which reduces the difficulty to solve the ECDLP
%    (i.e., it is possible for the RP to derive $ID_U$ from $Acct = [ID_U]{ID_{RP}}$
%        or at least some information about $ID_U$).
%%%%%%%%%% 因为E上面的点，构成循环群、当n是素数的时候。所以，不会形成攻击。
%%%%%%%%%% 不需要这个注意点

%\vspace{1mm}
\noindent\textbf{User Registration.}
UPPRESSO adopts a design of user registration similar to the ones in existing SSO systems.
Each user registers once at the IdP to set up a unique user identity $ID_U$ and the corresponding credential.
%$ID_U$ can be chosen by the user or the IdP, as long as it is unique for each user.

\vspace{1mm}
\noindent\textbf{SSO Login.} An SSO login instance is typically launched through a browser,
when a user requests to login to an RP.
It consists of five steps, namely script downloading, RP identity transformation, $PID_{RP}$ registration, identity-token generation, and $Acct$ calculation, as shown in Figure \ref{fig:process}.
In this figure,
    the operations by the IdP are linked by a vertical line,
        so are the RP's operations.
Two vertical lines split the user's operations into two groups (i.e., in two browser windows),
    one of which is to communicate with the IdP,
                 and the other with the target RP.
Each solid horizontal line means some messages between the user and the IdP (or the RP),
            and each dotted line means a \verb+postMessage+ invocation between two scripts (or windows) within the browser.

%In this figure, vertical bars stand for entity in the UPPRESSO system.
%At the user side, the vertical bars represent the browser's windows which are the containers of IdP and RP scripts.
%After a window is opened, the script in this window may change.
%For example, a window is opened at Step 1.2, and the script in this window belongs to the RP.
%However, after the redirection at Step 1.3, it visits the IdP server and downloads the script,
% so that the script inside this window changes into the IdP script.
%The main difference is that,
% the IdP script is only trusted by IdP server and allowed to communicate with IdP server.
% So does the RP script.

%%%, which calls three identifier-transformation functions following the login flow as shown in Figure \ref{fig:process}.
%%%Once a user attempts to login an RP, the SSO login is initiated.
%%%We use the OIDC implicit protocol flow as an example, to demonstrate  how to integrate the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the typical SSO systems.

\vspace{1mm}
\noindent 1. {\em Script Downloading.}
The browser downloads the scripts from the IdP and the visited RP.
\begin{itemize}
\item[1.1]
When attempting to visit any protected resources at the RP,
    the user downloads the RP script.
\item[1.2]
The RP script opens a window in the browser to visit the login path at the RP, which is then redirected to the IdP.
\item[1.3]
The redirection to the IdP downloads the IdP script.
\end{itemize}

\vspace{1mm}
\noindent{\em 2. RP Identity Transformation.}
The user and the RP negotiate $PID_{RP} = [t]{ID_{RP}}$.
\begin{itemize}
%\setlength{\itemsep}{0pt plus 1pt}
\item[2.1] The IdP script in the browser chooses a random number $t$ ($1 < t <n$) and sends it to the RP script through \verb+postMessage+.
Then, the RP script sends $t$ to the RP.
\item[2.2] On receiving $t$,
the RP verifies $1 < t < n$ and calculates $PID_{RP}$.
%To acknowledge the negotiation of $PID_{RP}$,
The RP replies with $Cert_{RP}$, which is then transmitted from the RP script to the IdP script.  % through \verb+postMessage+.
\item[2.3] The IdP script verifies $Cert_{RP}$, extracts $ID_{RP}$ and $Enpt_{RP}$ from $Cert_{RP}$ and calculates $PID_{RP}=[t]{ID_{RP}}$.
It then creates a random endpoint $PEnpt_{U}$ for this login instance,
    to receive identity tokens from the IdP.
    % as the RP endpoint required by IdP.我们已经修改了协议，IdP并不require什么

\end{itemize}

%It is important to ensure that the RP endpoint is not tampered with by the adversary. In other OIDC systems, the IdP obtains the RP endpoint from RP registration and verifies the endpoint in the identity-token request. However, the IdP in UPPRESSO sees only a one-time endpoint. So, we ask the user to verify the correctness of the RP endpoint using the RP certificate. %which is signed by the IdP.
\vspace{1mm}
\noindent{\em 3. ${PID_{RP}}$ Registration.}
The user dynamically registers an ephemeral $PID_{RP}$ at the IdP.
%It is conducted by the IdP script. %Otherwise, the IdP can associate $PID_{RP}$ and $ID_{RP}$.
\begin{itemize}
%\setlength{\itemsep}{0pt plus 1pt}

\item[3.1] The IdP script sends the $PID_{RP}$-registration request $[PID_{RP}, PEnpt_U, H(t)]$ to the IdP,
    where $H()$ is a collision-free one-way hash function.

\item[3.2] The IdP checks the list of unexpired $PID_{RP}$
    to verify the received $PID_{RP}$ is a unique point on $\mathbb{E}$ among them.
Then, it signs the response $[PID_{RP}, H(t), Validity]_{SK}$, %denoted as $RegToken$, 避免多余概念
 where $Validity$ indicates when $PID_{RP}$ will expire (typically, in 3 to 5 minutes).
The IdP maintains the list of unexpired $[PID_{RP}, PEnpt_U, H(t), Validity]$ and periodically deletes expired ones from it.

\item[3.3] The IdP script forwards the $PID_{RP}$-registration result to the RP through the RP script.

\item[3.4] The RP verifies the IdP's signature, and accepts the registration result
 only if $PID_{RP}$ and $H(t)$ match those in the negotiation and it does not expire.

\item[3.5] The RP constructs an identity-token request with $PID_{RP}$ and $Enpt_{RP}$,
    which is then forwarded to the IdP script through the RP script.

\end{itemize}
The $PID_{RP}$-registration result signed by the IdP
    ensures that $PID_{RP}$ is \emph{unique} within its validity;
        otherwise, RP designation is broken.
$H(t)$ is a \emph{necessary} nonce to distinguish different login instances,
 because there is a very small probability that
  an identical $PID_{RP}$ is calculated for two RPs from two different pairs of $ID_{RP}$ and $t$
   (i.e., $[t]ID_{RP_j} = [tr]G = [t'r']G = [t']ID_{RP_{j'}}$);\footnote{Although we assume $H()$ is collision-free,
                commonly-used one-way hash functions such as SHA-1 and SHA-256 are enough,
            because it is impossible that the following equations hold simultaneously:
            $r \neq r'$, $[tr]G = [t'r']G$, and $H(t) = H(t')$.}
otherwise,
                although $PID_{RP}$ is unique within its validity from the IdP's view,
                     multiple RPs still share an identical $PID_{RP}$.
This nonce prevents one $PID_{RP}$-registration result (and the subsequent identity token)
     from being accepted by different RPs.

\vspace{1mm}
\noindent{\em 4. Identity-Token Generation.}
The IdP calculates $PID_U = [ID_U]{PID_{RP}}$ and signs the identity token. % The processes are as follows.
\begin{itemize}

\item[4.1]
The IdP script checks that $PID_{RP}$ is the one registered in Step 3.1
            and $Enpt_{RP}$ matches the one in $Cert_{RP}$.
Then, it replaces $Enpt_{RP}$ with $PEnpt_{U}$ in the identity-token request
     and sends this modified request to the IdP.

\item[4.2] On receiving an identity-token request,
    the IdP authenticates the user if he has not been authenticated yet.

\item [4.3]
After obtaining the user's authorization to enclose the requested attributes,
the IdP checks whether the received pair of $PID_{RP}$ and $PEnpt_U$ is in the list of unexpired $PID_{RP}$ or not,
    and calculates $PID_U = [ID_U]{PID_{RP}}$ for the authenticated user.
The IdP then signs an identity token $[PID_{RP}, PID_U, Issuer, Validity, Attr]_{SK}$,
 where $Issuer$ is the IdP's identity, $Validity$ is the validity period, and $Attr$ contains the requested attributes.

\item[4.4] The IdP sends the identity token to $PEnpt_{U}$.

\end{itemize}

\vspace{1mm}
\noindent{\em 5. $Acct$ Calculation.}
The RP verifies the identity token and allows the user to login.
\begin{itemize}
%\setlength{\itemsep}{0pt plus 1pt}

\item [5.1]
The IdP script forwards this token to the RP script,
    which then sends it to the RP through $Enpt_{RP}$.
\item[5.2] The RP verifies the identity token, including the IdP's signature and its validity period.
It also verifies $PID_{RP}$ in the token is consistent with the one negotiated in Step 2.2.
Then, the RP extracts $PID_U$, and calculates $Acct = [t^{-1}]{PID_U}$.

\item [5.3] The RP returns the login result, and allows the user to login as $Acct$.

\end{itemize}


If any verification or check fails in some step,
 the flow will be halted immediately.
For example, the user halts the flow
    if $Cert_{RP}$ is invalid. % or $PID_{RP}$ in the identity-token request is inconsistent with the negotiated one.
The IdP rejects a $PID_{RP}$-registration request,
    if there is any unexpired but identical $PID_{RP}$ in the list,
    and the RP rejects identity tokens until it accepts a $PID_{RP}$-registration result.
The IdP rejects an identity-token request, if the pair of $PID_{RP}$ and $PEnpt_U$ is not in the unexpired list.
Or, the RP rejects an identity token
    if $PID_{RP}$ in the token does not match the negotiated one.


\begin{comment}
\subsection{SSO Login Flow of UPPRESSO}
\label{sebsec:loginprocess}

We illustrate the steps of the SSO login protocol of UPPRESSO in Figure \ref{fig:process}, %the SSO login sub-protocol provides the secure SSO service and prevents both the IdP-based login tracing and RP-based identity linkage.
 % prevents the curious IdP from obtaining the RP's identifying information during the interchanges,
%  and avoids the adversary to break the security and user's privacy.
and describe the detailed processes as follows.

\begin{figure*}
  \centering
  \includegraphics[width=0.68\linewidth]{fig/process-js.pdf}
  \caption{The flow of a user login in UPPRESSO.}
  \label{fig:process}
\end{figure*}

\vspace{1mm}\noindent\textbf{Scripts Downloading.}
At the beginning, the user downloads the scripts from RP and IdP as follows:\\

\begin{itemize}
\item[1.1] The user  visits the RP's script site and downloads the script.
\item[1.2] The script opens a new window in the browser visiting the login path at RP.
\item[1.3] The visit to RP's login path is redirected to IdP's script.
\item[1.4] The new window visits  the IdP's script site and downloads the script.
\end{itemize}

\vspace{1mm}\noindent\textbf{RP Identifier Transformation.}
In this step, the user and the RP cooperate to generate $PID_{RP}$ as follows:
\begin{itemize}
\item[2.1] The IdP script chooses a random number $N_U$ ($1 < N_U <q$) and sends it to RP script through postMessage, then RP script sends $N_U$ to RP.
\item[2.2] The RP  verifies $N_{U} \neq 0 \bmod q$, calculates $PID_{RP}$ with $N_U$, derives the trapdoor $T={(N_U N_{RP})}^{-1} \bmod q$; and  acknowledges the negotiation by responding with $Cert_{RP}$. The $Cert_{RP}$ is transmitted from RP script to IdP script through postMessage.
\item[2.3] The IdP script verifies $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$,  calculate $PID_{RP}={ID_{RP}}^{N_{U}} \bmod p$, creates a one-time endpoint to hide the RP's endpoint from the IdP and calculates $Nonce=Hash(N_U)$.


 % \item [1.1] The user sends a login request to trigger the negotiation of $PID_{RP}$.
%  \item [1.2] The RP chooses a random number $N_{RP}$ ($1 < N_{RP} <q$), calculates $Y_{RP}={ID_{RP}}^{N_{RP}} \bmod p$, % (Step 2.1.1);
%   and sends $Y_{RP}$ with $Cert_{RP}$  to the user. % (Step 2.1.2).
%  \item [1.3] The user verifies $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$, chooses a random number $N_U$ ($1 < N_U <q$) to calculate $PID_{RP}={Y_{RP}}^{N_{U}} \bmod p$, and sends $N_U$ %with $PID_{RP}$
%       to the RP.
%  \item [1.4] The RP verifies $N_{U} \neq 0 \bmod q$, calculates $PID_{RP}$ with $N_U$ and $Y_{RP}$, %checks its consistency with the received one,
 %  derives the trapdoor $T={(N_U N_{RP})}^{-1} \bmod q$; and
%   acknowledges the negotiation by responding with $N_{RP}$.
 % \item [1.5] The user verifies that $N_{RP} \neq 0 \bmod q$ and $Y_{RP} = {ID_{RP}}^{N_{RP}} \bmod p$.
   %sends the calculated $PID_{RP}$ to the user (Step 2.1.6).
%  \item The user checks the consistency of the received $PID_{RP}$ with the stored one.
\end{itemize}

The user halts the negotiation, if  $Cert_{RP}$ is invalid.
%The verification of $Y_{RP}$ and $N_{RP}$ ensures the order of $Y_{RP}$ (and also $PID_{RP}$) is $q$,
  %  and prevents a malicious RP from choosing an arbitrary $Y_{RP}$ (then $PID_{RP}$) of order less than $q$,
    %    which makes it less difficult for the RP to derive $ID_U$ from $PID_U$.
 %or the received $PID_{RP}$ is different from the stored one. The RP also halts the process if the $PID_{RP}$ sent by the user is inconsistent with the calculated one.
%The user verifies that  \textcolor[rgb]{1.00,0.00,0.00}{$PID_{RP}$ is in the cyclic  group defined by $g$},
%$PID_{RP} \neq g^0 \bmod p$;
%    if $PID_{RP} = g^0 \bmod p$, $PID_U = {g}^{0*ID_U}$ is constant for all users.
%This case appears only if  $N_U = 0 \bmod q$ or $N_{RP} = 0 \bmod q$.

\vspace{1mm}\noindent\textbf{$\mathbf{PID_{RP}}$ Registration.}
The user registers $PID_{RP}$ at the IdP.
\begin{itemize}

\item[3.1] The IdP script sends the ${PID_{RP}}$ registration request $[PID_{RP}, Hash( N_U), Endpoint_U]$ to the IdP.
\item[3.2] The IdP verifies that $PID_{RP}$ is unique among unexpired $PID_{RP}$s,
    and then signs the response $[PID_{RP}, Hash( N_U), Validity]_{SK}$,
        where $Validity$ is the validity period.
\item[3.3] The IdP script forwards the registration result to the RP through RP script.
\item[3.4] The RP verifies the IdP's signature, and accepts it only if $PID_{RP}$ and $Hash(N_U)$ match those in the negotiation and it is in the validity period.


 % \item [2.1] The user creates a one-time endpoint to hide the RP's endpoint from the IdP, and sends the ${PID_{RP}}$ registration request $[PID_{RP}, Hash(N_{RP}, N_U), Endpoint_U]$ to the IdP.
  %\item [2.2] The IdP authenticates the user if she has not been authenticated yet.
  %The IdP verifies that $PID_{RP}$ is unique among unexpired $PID_{RP}$s,
   % and then signs the response $[PID_{RP}, Hash(N_{RP}, N_U), Validity]_{SK}$,
      %  where $Validity$ is the validity period.
%The IdP returns the signed response to the user.
 % \item [2.3] The user forwards the registration result to the RP.
  %\item [2.4] The RP verifies the IdP's signature, and accepts it only if $PID_{RP}$ and $Hash(N_{RP}, N_U)$ match those in the negotiation and it is in the validity period.
\end{itemize}

%If $RegRes$ is $OK$, the RP identifier refreshing completes. Otherwise, the user and RP will renegotiate the $PID_{RP}$.
$Hash(N_U)$ is attached as the nonce to avoid the registration result is accepted by two or more RPs,
 which have different $ID_{RP}$s but generate a same $PID_{RP}$.  % with a negligible possibility.
The IdP ensures $PID_{RP}$ is unique among unexpired ones;
 otherwise, one identity token for one $PID_{RP}$ might be accepted by other RPs.
%The RP checks if Hash($N_{RP}$, $N_U$) matches,
%    to ensure this is signed for it (not for other RPs).
More details are analyzed in Section \ref{sec:analysis}.

\vspace{1mm}\noindent\textbf{ID Token Generation.}
In this step, the user login continues and the IdP signs the identity token. % The processes are as follows.
\begin{itemize}
\item[4.1] The RP uses $PID_{RP}$ and $Endpoint_{RP}$ to construct an identity-token request for a set of user's attributes, and the request is forwarded to IdP script through RP script.
\item[4.2] The IdP authenticates the user if she has not been authenticated yet.
 \item[4.3] The user first confirms the scope of the requested attributes. IdP script verifies the $PID_{RP}$ with the negotiated one and $Endpoint_{RP} \in Cert_{RP}$, replaces the endpoint with the registered one-time $Endpoint_U$ and then sends the modified identity-token request to the IdP.
 \item [4.4] The IdP verifies whether $PID_{RP}$ and $Endpoint_U$ have been registered and unexpired, and
   calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ for the authenticated user.
\item[4.5] The IdP constructs and signs the identity token $[PID_{RP}, PID_U, Iss, ValTime, Attr]_{SK}$, where $Iss$ is the identifier of the IdP,  $ValTime$ is the validity period, $Attr$ contains the requested attributes.
\item[4.6]Then, the IdP sends the identity token to the one-time endpoint at the user. The IdP script forwards the identity token to RP script with the origin $Endpoint_{RP}$ and RP script sends it to the server.

%  \item [3.1] The RP uses $PID_{RP}$ and $Endpoint_{RP}$ to construct an identity-token request for a set of user's attributes.  %, which is the same as the one in  OIDC.

 %\item [3.2] The user first confirms the scope of the requested attributes and verifies $PID_{RP}$ with the negotiated one. The user replaces the endpoint with the registered one-time $Endpoint_U$, and sends the modified identity-token request to the IdP.
%  \item [3.3] The IdP verifies whether $PID_{RP}$ and $Endpoint_U$ have been registered and unexpired, and
%   calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ for the authenticated user.
%\item [3.4] The IdP constructs and signs the identity token $[PID_{RP}, PID_U, Iss, ValTime, Attr]_{SK}$, where $Iss$ is the identifier of the IdP,  $ValTime$ is the validity period, $Attr$ contains the requested attributes. Then, the IdP sends the identity token to the one-time endpoint at the user.
%  \item [3.5] The user extracts the RP endpoint in $Cert_{RP}$,
  % and forwards the identity token to the RP through this endpoint.
\end{itemize}

The user halts the process if $PID_{RP}$ in the identity-token request is inconsistent with  the negotiated one.
The IdP rejects the identity-token request, if the pair of $PID_{RP}$ and $Endpoint_U$ has not been registered.


\vspace{1mm}\noindent\textbf{$\mathbf{Account}$ calculation.}
Finally, RP derives the user's  $Account$ and completes the user login as follows.
\begin{itemize}
\item[5.1]
The RP verifies the identity token, including the signature, validity period, and the consistency between $PID_{RP}$ and the negotiated one. If any fails, the RP rejects this login.
\item [5.2] The RP extracts $PID_U$, calculates $Accout = {PID_U}^T \bmod p$, and allows the user to login.
\end{itemize}
%
%\begin{figure}[t]
%  \centering
%  \includegraphics[width=\linewidth]{fig/overview1.pdf}
%  \caption{UPPRESSO compatibility with OIDC.}
%  \label{fig:UPPRESSO}
%\end{figure}
%

\end{comment}



\begin{comment}
\vspace{1mm}
\begin{strip}
\centering\includegraphics[width=0.5\textwidth]{fig/process-js.pdf}
\captionof{figure}{The flow of a user login in UPPRESSO.}
\label{fig:process}
\vspace{-5mm}
\end{strip}
\end{comment}

\subsection{Compatibility with OIDC}
\label{subsec:compatible}
%We explain the compatibility with OIDC,
%    and this compatibility helps us to analyze, implement and deploy UPPRESSO.
% 这句话前面已经说过了


Among the five steps of the SSO login flow in UPPRESSO,
    the script downloading prepares the user agent.
The user agent of SSO is responsible for the communications between the IdP and the RP,
    which are implemented by browser redirections in OIDC.
On the other hand, in UPPRESSO
    when sending the identity-token request,
        the script replaces $Enpt_{RP}$ with $PEnpt_{U}$,
    and then
            the script forwards the identity token to $Enpt_{RP}$ which is extracted from the RP certificate.

In the step of RP identity transformation, most operations are conducted by the user agent,
 while the RP only receives $t$ to calculate $PID_{RP}$ and sends $Cert_{RP}$.
The operations in the $PID_{RP}$ registration are almost identical to those in the RP Dynamic Registration of OIDC \cite{DynamicRegistration},
    except that
    in OIDC the IdP assigns the RP's identity  while in UPPRESSO this (pseudo-)identity is generated by the registered entity.
Besides, the $PID_{RP}$ registration has a validity period.

The operations of identity-token generation and $Acct$ calculation,
    are actually identical to those in the implicit SSO login flow of OIDC \cite{OpenIDConnect},
    because (\emph{a}) the calculation of $PID_U$ is viewed as a method to generate PPIDs by the IdP
        and (\emph{b}) the calculation of $Acct$ is viewed as a mapping from the user identity in tokens
                    to the local account at the RP.


%It follows a similar logic flow as OIDC in SSO login and only requires small modifications to perform identifier transformation.
%Here, we explain the modification in each of the five steps of its SSO login flow to show that UPPRESSO is compatible with OIDC, which indicates UPPRESSO can be easily integrated with other commonly used SSO systems.
%Among the five steps,
% the {\em scripts downloading} and {\em RP identifier transformation} steps are newly introduced by UPPRESSO.
%The browser is required to download two scripts from the IdP and RP and most of the designed operations in these two steps are performed by the scripts in the browser.
%So, we require minimal modifications to the IdP and RPs providing new network interfaces (i.e., the new URLs for downloading resources).
%The other three steps adopt a similar communication pattern as OIDC.
%In particular, the {\em $PID_{RP}$ registration} step can be viewed as a variant of the RP dynamic registration flow of OIDC \cite{DynamicRegistration}, which allows an entity to register its identity and endpoint at the IdP.

%UPPRESSO can also support the authorization code flow of OIDC with small modifications (to be discussed in Section \ref{sec:discussion}).


%Different from OIDC in which only RPs can call a dynamic registration, UPPRESSO allows any authenticated user to launch this process and register an RP identifier with the IdP.
%The {\em identity token generation} and {\em $Account$ calculation} steps adopt the same steps and functions as the implicit protocol flow of OIDC, while using a few different parameters. First, in identity token generation, $PID_U$ transformed from $ID_U$ is used to replace $ID_U$, which is directly supported by OIDC, similar as in the PPID approaches that also convert $ID_U$ into $PID_U$. The calculation of $Account$ from $PID_U$
%can be viewed as a customized step by the RP to derive its user account after the implicit protocol flow of OIDC ends.

%So,the identity token generation and $Account$ calculation steps of UPPRESSO can be viewed as a particular but compatible implementation of the implicit protocol flow of OIDC. It is worth noting that the identity token generation and $Account$ calculation steps of
%As shown in Figure \ref{fig:process}, in UPPRESSO, the SSO protocol for identity token is the same as in OIDC; the formats of identity token and corresponding request are the same as in OIDC; the correctness checks on the identity-token request at the IdP (i.e., consistency of RP' identifier and endpoint with the registered one) are the same as in OIDC; the correctness checks on the identity token (i.e., consistency of RP' identifier with the one in the request, integrity, validity time, freshness, and etc.) at the RP are the same as in OIDC.
%The above modifications could be completed automatically for each login, without affecting other communication pattern.

%以下为描述Step 2.3到7的详细内容.
%That is, the RP construct a request for identity token (Step 2.3); the user redirects this request to the IdP (Step 2.5); the IdP generates the identity token (Step 4), and sends it to the user (Step 5.1) who redirects it to the RP (Step 5.3); and finally the RP verifies the identity token (Step 6).

%However, UPPRESSO achieves privacy preservation by integrating  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, and  introduces the following modifications on OIDC.

%\begin{enumerate}
%  \item The identity token is bound with $PID_{RP}$ instead of $ID_{RP}$, which introduces the RP identifier transforming (Steps 1.2-1.5)  and $PID_{RP}$ registration (Steps 2.1-2.4).
%  \item The identity token is designated to one-time endpoint instead of RP's identifying endpoint, which requires the user to register the one-time endpoint in Step 2.1 and replace it with the original endpoint in Step 3.2.
%  \item IdP generates $PID_U$ based on ($PID_{RP}$, $ID_U$) instead of ($ID_{RP}$, $ID_U$).
%  \item The RP calculates $Account$ from the changing $PID_U$ instead of an unchanged one.
%\end{enumerate}

%上述modification如何实现的，简单描述
%to add: PID_{RP} transforming 和 RP identifer refreshing在user和RP的页面自己完成了。 都用现成的数据格式
%one-time endpoint 和endpoint
%The user automatically invokes the JavaScript functions to complete RP identifier transforming, one-time endpoint generating/replacing and $PID_{RP}$ registration for each login.
%While, the RP and IdP provide the corresponding web service to complete the processing automatically.

%The protocol of RP identifier transformation is based Diffie-Hellman key exchange \cite{DiffieH76}, while $N_U$ is provided to RP for computing the trapdoor and $N_{RP}$ is provided to the user for verifying the correctness of $Y_{RP}$.

\begin{comment}
\vspace{1mm}\noindent \textbf{Consistency with OIDC.}
As shown in Figure \ref{fig:UPPRESSO}, the architecture of UPPRESSO is the same as the one in OIDC. UPPRESSO does not introduce any new entity, but only integrates the three function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the processes at the IdP, RP, and user.

The formats of the  identity token and corresponding request, and the verification of the identity token,  are almost same in OIDC and UPPRESSO.
The only difference is that $ID_{RP}$ and endpoint are replaced with the privacy-preserving versions, i.e., $PID_{RP}$ and one-time endpoint, in UPPRESSO.
As $PID_{RP}$ is also unique and corresponds exactly to $ID_{RP}$, and one-time endpoint corresponds to the RP's endpoint correctly,
 the binding, integrity and confidentiality of identity token will also be ensured in UPPRESSO, and there is no degradation on the security of OIDC.

\vspace{1mm}\noindent \textbf{Minimal modification to OIDC.}
UPPRESSO only requires small modification on OIDC to integrate $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$.
For $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, we directly use them to replace original functions for $PPID$ at the IdP and the $Account$ at the RP.
For $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, we inject a negotiation process and a dynamic registration for each SSO login,
 where the negotiation process between the user and RP generates a $PID_{RP}$,
  while the dynamic registration is used to check the uniqueness of $PID_{RP}$.
In UPPRESSO, the dynamic registration is slightly modified as follows: an RP identifer ($PID_{RP}$)  is added in the request, and a signature ($Sig_{Res}$)  is included in the response for its verification at the RP.
\end{comment}
